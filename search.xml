<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>disk test</title>
    <url>/2021/03/10/disk-test/</url>
    <content><![CDATA[<p>最近看&lt;&lt;大话存储&gt;&gt;这本书，书中硬件架构部分的东西触及不到，认识不深刻，为了对于磁盘性能有接触，云上试用了两台服务器，对其性能指标进行测试。</p>
<ul>
<li>1.性能指标<br>iops，shorted for input output per sencond,每秒读写的次数<br>吞吐量，每秒磁盘写入及读出的数据量<br>时延，单个读写操作被处理的时间</li>
<li>2.性能测试工具<br>fio:该命令参数较多，可以测试随机写，随机读，混合随机读写等，写吞吐量，读吞吐量等，切记，fio写命令尽量不要在系统盘测试，会破坏文件系统，造成不可挽回的失误</li>
</ul>
<p>dd:该命令比较简单,能大致获取读写速率<br>写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;test.file bs&#x3D;1M count&#x3D;2 oflag&#x3D;direct</span><br></pre></td></tr></table></figure>
<p>读：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time dd if&#x3D;test.file of&#x3D;&#x2F;dev&#x2F;null  iflag&#x3D;direct</span><br></pre></td></tr></table></figure>
<ul>
<li>3.磁盘性能监控<br>top命令中的wa值用来判断磁盘IO性能<br>sar命令(yum -y install sysstat)<br>iostat命令<br>ioping磁盘IO的延迟监测工具<br>关于这些命令各指标的含义，有时间出一篇文章详细说明</li>
</ul>
]]></content>
      <tags>
        <tag>disk</tag>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title>openssl experiment</title>
    <url>/2021/03/10/openssl-experiment/</url>
    <content><![CDATA[<p>k8s中各组件与master的通讯使用http，如果apiserver需要对外提供服务，则应该使用安全系数更高的https,k8s提供基于CA签名的双向数字证书认证方式和简单基于HTTP BASE 或TOKEN的认证方式，CA证书的安全性最高，基于此，openssl的TLS证书相关理论对入门者来说是必须，本文参考《openssl-cookbook》，实践大多源于此书。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wget https://www.openssl.org/source/openssl-1.1.1g.tar.gz</span></span><br><span class="line"><span class="comment"># ./config \</span></span><br><span class="line">  --prefix=/opt/openssl \</span><br><span class="line">  --openssldir=/opt/openssl \</span><br><span class="line">  no-shared \</span><br><span class="line">  -DOPENSSL_TLS_SECURITY_LEVEL=2 \</span><br><span class="line">  enable-ec_nistp_64_gcc_128</span><br><span class="line"> <span class="comment"># make &amp;&amp; make install</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 生成RSA key</span></span><br><span class="line"></span><br><span class="line">``` bash</span><br><span class="line"><span class="comment"># openssl genpkey -out fd.key \</span></span><br><span class="line">  -algorithm RSA \</span><br><span class="line">  -pkeyopt rsa_keygen_bits:2048 \</span><br><span class="line">  -aes-128-cbc</span><br><span class="line">输入密码：</span><br></pre></td></tr></table></figure>

<p>查看rsa格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># openssl pkey -in fd.key -text -noout</span></span><br></pre></td></tr></table></figure>

<p>生成共钥匙：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># openssl pkey -in fd.key -pubout -out fd-public.key</span></span><br></pre></td></tr></table></figure>

<p>生成证书请求CSR,输入交互式的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># openssl req -new -key fd.key -out fd.csr</span></span><br></pre></td></tr></table></figure>
<p>（CSR creation is usually an interactive process during which you’ll be providing the elements of the certificate distinguished name. Read the instructions given by the openssl tool careful- ly; if you want a field to be empty, you must enter a single dot (.) on the line, rather than just hit Return. If you do the latter, OpenSSL will populate the corresponding CSR field with the default value. (This behavior doesn’t make any sense when used with the default OpenSSL configuration, which is what virtually everyone does. It does make sense once you realize you can actually change the defaults, either by modifying the OpenSSL configuration or by pro- viding your own configuration files.)）<br>According to Section 5.4.1 of RFC 2985,12 challenge password is an optional field that was intended for use during certificate revocation as a way of identifying the original entity that had requested the certificate. If entered, the password will be included verbatim in the CSR and communicated to the CA. It’s rare to find a CA that relies on this field; all instructions I’ve seen recommend leaving it alone. Having a challenge password does not increase the security of the CSR in any way. Further, this field should not be confused with the key passphrase, which is a separate feature</p>
<p>检查证书请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># openssl req -text -in fd.csr -noout</span></span><br></pre></td></tr></table></figure>
<p>生成自签证书：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># openssl x509 -req -days 365 -in fd.csr -signkey fd.key -out fd.crt</span></span><br></pre></td></tr></table></figure>
<p>You don’t actually have to create a CSR in a separate step. The following command creates a self-signed certificate starting with a key alone:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># openssl req -new -x509 -days 365 -key fd.key -out fd.crt</span></span><br></pre></td></tr></table></figure>
<p>If you don’t wish to be asked any questions, use the -subj switch to provide the certificate<br>subject information on the command line:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># openssl req -new -x509 -days 365 -key fd.key -out fd.crt \</span></span><br><span class="line">   -subj <span class="string">&quot;/C=GB/L=London/O=Feisty Duck Ltd/CN=www.feistyduck.com&quot;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>pod</title>
    <url>/2021/03/10/pod/</url>
    <content><![CDATA[<p>1.如果pod中运行两个容器，这两个容器的相当于在pod上ip运行，要注意端口是否有冲突</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat pod2container.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">   name: tomcat</span><br><span class="line">   labels:</span><br><span class="line">      app: tomcat</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">        - name: nginx</span><br><span class="line">          image: nginx:latest</span><br><span class="line">          ports:</span><br><span class="line">          - containerPort: 8080</span><br><span class="line">        - name: t2</span><br><span class="line">          image: tomcat:8.0</span><br><span class="line">          ports:</span><br><span class="line">          - containerPort: 9090</span><br><span class="line"># kuberctl get pods -o wide</span><br><span class="line"># curl http:&#x2F;&#x2F;ip:8080</span><br><span class="line"># curl http:&#x2F;&#x2F;ip:80</span><br></pre></td></tr></table></figure>
<p>2.静态pod<br>静态pod直接由某个节点上的kubelet程序进行管理，不需要api server介入，可以通过配置文件方式和http方式<br>3.pod中使用configmap的环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat conpod.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: cm-appvars</span><br><span class="line">data:</span><br><span class="line">   apploglevel: info</span><br><span class="line">   appdatadir: &#x2F;var&#x2F;data</span><br><span class="line">cat podconfig.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: cm-test-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: cm-test</span><br><span class="line">    image: tomcat:8.0</span><br><span class="line">    command: [ &quot;&#x2F;bin&#x2F;sh&quot;,&quot;-c&quot;,&quot;env | grep APP&quot; ]</span><br><span class="line">    env:</span><br><span class="line">    - name: APPLOGLEVEL</span><br><span class="line">      valueFrom:</span><br><span class="line">       configMapKeyRef:</span><br><span class="line">         name: cm-appvars</span><br><span class="line">         key: apploglevel</span><br><span class="line">    - name: APPDATADIR</span><br><span class="line">      valueFrom:</span><br><span class="line">       configMapKeyRef:</span><br><span class="line">         name: cm-appvars</span><br><span class="line">         key: appdatadir</span><br><span class="line"># kubctl logs cm-test-pod</span><br></pre></td></tr></table></figure>
<p>4.在容器内获取Pod信息(Downward API)<br>5.Pod的生命周期(RestartPolicy)<br>6.Pod健康检查-探针(LivenessProbe和ReadinessProbe)<br>7.pod亲和性反亲和性topology污点容忍<br>8.DaemonSet在每个node上调度一个Pod</p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables</title>
    <url>/2021/03/13/iptables/</url>
    <content><![CDATA[<p>1.禁止ping</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT -p icmp -j REJECT</span><br><span class="line">iptables -L (默认是filter表)</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">REJECT     icmp --  anywhere             anywhere             reject-with icmp-port-unreachable</span><br></pre></td></tr></table></figure>
<p>2.去除禁ping</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t filter -D INPUT -p icmp -j REJECT</span><br></pre></td></tr></table></figure>
<p>3.禁用某一地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -s 10.211.55.2 -j </span><br><span class="line">iptables -I INPUT -s 10.211.55.0&#x2F;24 -j REJECT</span><br></pre></td></tr></table></figure>
<p>4.物理接口的设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -i eth0 -j DROP</span><br></pre></td></tr></table></figure>
<p>5.设置协议的某些端口应用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -s 10.211.55.2 -p tcp --dport 80 -j ACCEPT</span><br><span class="line">iptables -I INPUT -s 10.211.55.2 -p tcp --dport 22 -j REJECT</span><br></pre></td></tr></table></figure>
<p>6.设置TCP的某一种类型的包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -i eth0 -p tcp --tcp-flags SYN,RST,ACK SYN -j DROP</span><br></pre></td></tr></table></figure>
<p>当前已经远程连接的ssh不受影响，但是重新握手会失败，连接不上<br>7.单项ping的控制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p icmp --icmp-type 8 -j DROP</span><br></pre></td></tr></table></figure>
<p>icmp请求是8，应答是0,自己可以单向ping其他机器<br>8.一次放行多个端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m multiport --dport 80,21,22 -j DROP</span><br></pre></td></tr></table></figure>
<p>9.多IP的设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp -m iprange --src-range 10.211.55.2 10.211.55.8 -j DROP</span><br></pre></td></tr></table></figure>
<p> 10.tcp连接中状态的设置<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br></pre></td></tr></table></figure><br> 11.常用网络配置<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> IPT&#x3D;&quot;&#x2F;sbin&#x2F;iptables&quot;</span><br><span class="line">$IPT --delete-chain</span><br><span class="line">$IPT --flush</span><br><span class="line">$IPT -P INPUT DROP    #1</span><br><span class="line">$IPT -P FORWARD DROP  #1</span><br><span class="line">$IPT -P OUTPUT DROP   #1</span><br><span class="line">$IPT -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT #2</span><br><span class="line">$IPT -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT #3</span><br><span class="line">$IPT -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT #3</span><br><span class="line">$IPT -A INPUT -p tcp -m tcp --dport 21 -j ACCEPT  #3</span><br><span class="line">$IPT -A INPUT -p tcp -m tcp --dport 873 -j ACCEPT #3</span><br><span class="line">$IPT -A INPUT -i lo -j ACCEPT #4</span><br><span class="line">$IPT -A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT  #5</span><br><span class="line">$IPT -A INPUT -p icmp -m icmp --icmp-type 11 -j ACCEPT #5</span><br><span class="line">$IPT -A OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT #6</span><br><span class="line">$IPT -A OUTPUT -p udp -m udp --dport 53 -j ACCEPT #7</span><br><span class="line">$IPT -A OUTPUT -o lo -j ACCEPT #4</span><br><span class="line">$IPT -A OUTPUT -p tcp -m tcp --dport 80 -j ACCEPT #8</span><br><span class="line">$IPT -A OUTPUT -p tcp -m tcp --dport 25 -j ACCEPT #9</span><br><span class="line">$IPT -A OUTPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT  #10</span><br><span class="line">$IPT -A OUTPUT -p icmp -m icmp --icmp-type 11 -j ACCEPT #10</span><br><span class="line">service iptables save</span><br><span class="line">service iptables restart</span><br><span class="line">存为脚本iptables.sh，执行sh iptables.sh自动配置防火墙。</span><br><span class="line">解释：</span><br><span class="line">#1、设置INPUT,FORWARD,OUTPUT链默认target为DROP，也就是外部与服务器不能通信。</span><br><span class="line">#2、设置当连接状态为RELATED和ESTABLISHED时，允许数据进入服务器。</span><br><span class="line">#3、设置外部客户端连接服务器端口80,22,21,873。</span><br><span class="line">#4、允许内部数据循回。</span><br><span class="line">#5、允许外部ping服务器 。</span><br><span class="line">#6、设置状态为RELATED和ESTABLISHED的数据可以从服务器发送到外部。</span><br><span class="line">#7、允许服务器使用外部dns解析域名。</span><br><span class="line">#8、设置服务器连接外部服务器端口80。</span><br><span class="line">#9、允许服务器发送邮件。</span><br><span class="line">#10、允许从服务器ping外部。</span><br></pre></td></tr></table></figure><br> 脚本转自：<a href="https://www.centos.bz/2011/09/example-webserver-iptable-ruleset/">https://www.centos.bz/2011/09/example-webserver-iptable-ruleset/</a></p>
]]></content>
      <tags>
        <tag>防火墙</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins</title>
    <url>/2021/03/15/jenkins/</url>
    <content><![CDATA[<p>选择一个LTS(long time support)jenkins版本<br>夜间构建+自动化测试+度量指标<br>1.jenkins的目录结构<br> build目录存放所有构建数据，历史记录，可以迁移使用，历史数据过多可以设置Discard old buildings保留策略管理<br> jobs目录中包含配置运行的job，以xml形式显示<br>2.变量引用<br> 系统配置-&gt;全局属性中可以定义变量，在构建配置中可以使用${varname}来使用变量<br>3.调整触发构建的规则<br>  include path和exclude path匹配正则表达式，识别不该触发构建的文件，或者哪些用户的限制<br>4.各种插件<br>  构建通知邮件，即时消息，代码复杂度静态检查等<br>5.构建参数<br>  参数的设置，获取及传递，一般用于手动触发构建<br>6.多重结构的构建作业<br>  多组有效组合进行构建，节点设置标签(如数据库，操作系统)，可以设置无效的过滤器<br>7.依赖关系图<br>8.汇总测试结果<br>  需要饱含相同指纹构建的产物<br>9.分布式架构<br>  从节点的安装方式有两种，ssh，JNLP(拷贝slave.jar包，命令行启动)，正则表达式匹配可以运行的节点<br>10.监控<br>  磁盘监控disk-usage插件，计算资源监控monit插件<br>11.jenkins备份<br>  workspace目录无需备份，如果丢失会自动生成，build是构建的历史记录,backup和thinback插件都可以，定期备份策略及恢复到指定版本<br>  项目归档–手动操作<br>  jenkins的迁移<br>12.自动化测试<br>本书阅读完毕，maven使用部分没有吃透，还可以看第二遍，有时间可以参加CJE和CCJE的线上考试，价格99$,后续要读的书：<br><a href="https://github.com/PacktPublishing/Continuous-Delivery-with-Docker-and-Jenkins-Second-Edition/">https://github.com/PacktPublishing/Continuous-Delivery-with-Docker-and-Jenkins-Second-Edition/</a><br>期待有更大的收获。。。    </p>
]]></content>
      <tags>
        <tag>自动发布</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>scurity</title>
    <url>/2021/03/14/scurity/</url>
    <content><![CDATA[<p>本书讲的安全的基本理论，CIA,threat model,security level<br>1编译安装和二进制安装的区别<br>编译安装需要收集模块，花费时间，可以二次开发代码，灵活性大<br>二进制包是经过编译的代码包，安装简单，默认配置，看不到源码<br>rpm安装工具可以是安装源码，也可以安装二进制<br>2.常用安全措施<br>#a.启动用户设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># groupadd httpd</span><br><span class="line"># useradd httpd -g httpd -d &#x2F;dev&#x2F;null -s &#x2F;sbin&#x2F;nologin</span><br></pre></td></tr></table></figure>
<p>调整httpd.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User httpd</span><br><span class="line">Group httpd</span><br></pre></td></tr></table></figure>
<p>#b.文件权限设置，80端口启动需要root权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># chown -R root:root &#x2F;usr&#x2F;local&#x2F;apache</span><br><span class="line"># chmod -R go-w &#x2F;usr&#x2F;local&#x2F;apache</span><br><span class="line"># chmod -R go-r &#x2F;usr&#x2F;local&#x2F;apache&#x2F;conf </span><br><span class="line"># chmod -R go-r &#x2F;usr&#x2F;local&#x2F;apache&#x2F;logs</span><br></pre></td></tr></table></figure>
<p>#c.文件权限设置，非任何文件都可见,配置httpd.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Directory &#x2F;&gt;</span><br><span class="line">    Order Deny,Allow</span><br><span class="line">    Deny from all</span><br><span class="line">&lt;&#x2F;Directory&gt;</span><br><span class="line">&lt;Directory &#x2F;var&#x2F;www&#x2F;htdocs&gt;</span><br><span class="line">    Order Allow,Deny</span><br><span class="line">    Allow from all</span><br><span class="line">&lt;&#x2F;Directory&gt;</span><br></pre></td></tr></table></figure>
<p>#d.禁用符号连接，使用Alias</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Options -FollowSymLinks</span><br><span class="line">Alias &#x2F;manual&#x2F; &#x2F;usr&#x2F;local&#x2F;apache&#x2F;manual&#x2F;</span><br></pre></td></tr></table></figure>
<p>或者要使用符号连接，推荐开启用户检测功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Options -FollowSymLinks +SymLinksIfOwnerMatch</span><br></pre></td></tr></table></figure>
<p>#e.收回服务端脚本执行权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Options -Includes -ExecCGI</span><br></pre></td></tr></table></figure>
<p>#f.特定的目录执行脚背</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Directory &#x2F;var&#x2F;www&#x2F;cgi-bin&gt;</span><br><span class="line">    Options ExecCGI</span><br><span class="line">    SetHandler cgi-script</span><br><span class="line">&lt;&#x2F;Directory&gt;</span><br></pre></td></tr></table></figure>
<p>3.日志<br> First, use the LogFormat directive to define a logging format. Then, use the CustomLog directive to create an access log in that format:<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LogFormat &quot;%h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot;&quot; combined</span><br><span class="line">CustomLog &#x2F;var&#x2F;www&#x2F;logs&#x2F;access_log combined</span><br></pre></td></tr></table></figure><br>4.配置限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># wait up to 300 seconds for slow clients</span><br><span class="line"> TimeOut 60</span><br><span class="line"> # allow connections to be reused between requests</span><br><span class="line"> KeepAlive On</span><br><span class="line"> # allow a maximum of 100 requests per connection</span><br><span class="line"> MaxKeepAliveRequests 100</span><br><span class="line"> # wait up to 15 seconds for the next</span><br><span class="line"> # request on an open connection</span><br><span class="line"> KeepAliveTimeout 15</span><br></pre></td></tr></table></figure>
<p>请求的限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># impose no limits on the request body</span><br><span class="line"> LimitRequestBody 0</span><br><span class="line"> # allow up to 100 headers in a request</span><br><span class="line"> LimitRequestFields 100</span><br><span class="line"> # each header may be up to 8190 bytes long</span><br><span class="line"> LimitRequestFieldsize 8190</span><br><span class="line"> # the first line of the request can be</span><br><span class="line"> # up to 8190 bytes long</span><br><span class="line"> LimitRequestLine 8190</span><br><span class="line"> # limit the XML request body to 1 million bytes(Apache 2.x only)</span><br><span class="line"> LimitXMLRequestBody 1000000</span><br></pre></td></tr></table></figure>
<p>服务端实例的限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># keep 5 servers ready to handle requests</span><br><span class="line">MinSpareServers 5</span><br><span class="line"># do not keep more than 10 servers idle</span><br><span class="line">MaxSpareServers 10</span><br><span class="line"># start with 5 servers</span><br><span class="line">StartServers 5</span><br><span class="line"># allow a max of 150 clients at any given time</span><br><span class="line">MaxClients 150</span><br><span class="line"># allow unlimited requests per server</span><br><span class="line">MaxRequestsPerChild 0</span><br></pre></td></tr></table></figure>
<p>Apache 2 introduces the concept of multiprocessing modules (MPMs), which are special-pur- pose modules that determine how request processing is organized. Only one MPM can be ac- tive at any one time. MPMs were introduced to allow processing to be optimized for each op- erating system individually. The Apache 1 processing model (multiple processes, no threads, each process handling one request at one time) is called prefork, and it is the default process- ing model in Apache 2 running on Unix platforms. On Windows, Apache always runs as a single process with multiple execution threads, and the MPM for that is known as winnt. On Unix systems running Apache 2, it is possible to use the worker MPM, which is a hybrid, as it supports many processes each with many threads. For the worker MPM, the configuration is similar to the following (refer to the documentation for the complete description):<br>在进程–线程MPM模型上控制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># the maximum number of processes</span><br><span class="line">ServerLimit 16</span><br><span class="line"># how many processes to start with</span><br><span class="line">StartServers 2</span><br><span class="line"># how many threads per process to create</span><br><span class="line">ThreadsPerChild 25</span><br><span class="line"># minimum spare threads across all processes</span><br><span class="line">MinSpareThreads 25</span><br><span class="line"># maximum spare threads across all processes</span><br><span class="line">MaxSpareThreads 75</span><br><span class="line"># maximum clients at any given time</span><br><span class="line">MaxClients 150</span><br></pre></td></tr></table></figure>
<p>5.关闭正则匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;(^\.ht|~$|\.bak$|\.BAK$)&quot;&gt;</span><br><span class="line">    Order Allow,Deny</span><br><span class="line">    Deny from all</span><br><span class="line">&lt;&#x2F;FilesMatch&gt;</span><br></pre></td></tr></table></figure>
<p>6.修改服务头<br>源码中修改core.c文件，编译后文件修改ap_release.h，还可以通过第三方模块mod_security添加配置修改，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Reveal full identity (standard Apache directive)</span><br><span class="line">ServerTokens Full</span><br><span class="line"># Replace the server name (mod_security directive)</span><br><span class="line">SecServerSignature &quot;Microsoft-IIS&#x2F;5.0&quot;</span><br></pre></td></tr></table></figure>
<p>apache2模块mod_headers修改头信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Header set Server &quot;Microsoft-IIS&#x2F;5.0&quot;</span><br></pre></td></tr></table></figure>
<p>这种修改方式对于异常请求不生效，如状态吗400<br>7.chroot的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir &#x2F;chroot</span><br><span class="line">mkdir &#x2F;chroot&#x2F;bin</span><br><span class="line">cp &#x2F;bin&#x2F;bash &#x2F;chroot&#x2F;bin&#x2F;bash</span><br><span class="line">chroot &#x2F;chroot &#x2F;bin&#x2F;bash</span><br><span class="line">ldd &#x2F;bin&#x2F;bash  #查看依赖</span><br><span class="line"># mkdir &#x2F;chroot&#x2F;lib</span><br><span class="line"># cp &#x2F;lib&#x2F;libtermcap.so.2 &#x2F;chroot&#x2F;lib </span><br><span class="line"># cp &#x2F;lib&#x2F;libdl.so.2 &#x2F;chroot&#x2F;lib</span><br><span class="line"># cp &#x2F;lib&#x2F;tls&#x2F;libc.so.6 &#x2F;chroot&#x2F;lib </span><br><span class="line"># cp &#x2F;lib&#x2F;ld-linux.so.2 &#x2F;chroot&#x2F;lib</span><br><span class="line">chroot &#x2F;chroot &#x2F;bin&#x2F;bash</span><br><span class="line"># mkdir -p &#x2F;chroot&#x2F;apache&#x2F;usr&#x2F;local</span><br><span class="line"># mv &#x2F;usr&#x2F;local&#x2F;apache &#x2F;chroot&#x2F;apache&#x2F;usr&#x2F;local</span><br><span class="line"># ln -s &#x2F;chroot&#x2F;apache&#x2F;usr&#x2F;local&#x2F;apache &#x2F;usr&#x2F;local&#x2F;apache </span><br><span class="line"># mkdir -p &#x2F;chroot&#x2F;apache&#x2F;var</span><br><span class="line"># mv &#x2F;var&#x2F;www &#x2F;chroot&#x2F;apache&#x2F;var&#x2F;</span><br><span class="line"># ln -s &#x2F;chroot&#x2F;apache&#x2F;var&#x2F;www &#x2F;var&#x2F;www</span><br><span class="line"># ldd &#x2F;chroot&#x2F;apache&#x2F;usr&#x2F;local&#x2F;apache&#x2F;bin&#x2F;httpd</span><br><span class="line"># mkdir &#x2F;chroot&#x2F;apache&#x2F;lib</span><br><span class="line"># cp &#x2F;lib&#x2F;tls&#x2F;libm.so.6 &#x2F;chroot&#x2F;apache&#x2F;lib</span><br><span class="line"># cp &#x2F;lib&#x2F;libcrypt.so.1 &#x2F;chroot&#x2F;apache&#x2F;lib</span><br><span class="line"># cp &#x2F;usr&#x2F;lib&#x2F;libgdbm.so.2 &#x2F;chroot&#x2F;apache&#x2F;lib # cp &#x2F;usr&#x2F;lib&#x2F;libexpat.so.0 &#x2F;chroot&#x2F;apache&#x2F;lib # cp &#x2F;lib&#x2F;libdl.so.2 &#x2F;chroot&#x2F;apache&#x2F;lib</span><br><span class="line"># cp &#x2F;lib&#x2F;tls&#x2F;libc.so.6 &#x2F;chroot&#x2F;apache&#x2F;lib</span><br><span class="line"># cp &#x2F;lib&#x2F;ld-linux.so.2 &#x2F;chroot&#x2F;apache&#x2F;lib</span><br><span class="line"># mkdir &#x2F;chroot&#x2F;apache&#x2F;etc</span><br><span class="line"># cp &#x2F;etc&#x2F;nsswitch.conf &#x2F;chroot&#x2F;apache&#x2F;etc&#x2F;</span><br><span class="line"># cp &#x2F;lib&#x2F;libnss_files.so.2 &#x2F;chroot&#x2F;apache&#x2F;lib</span><br><span class="line"># echo &quot;httpd:x:500:500:Apache:&#x2F;:&#x2F;sbin&#x2F;nologin&quot; &gt; &#x2F;chroot&#x2F;apache&#x2F;etc&#x2F;passwd </span><br><span class="line"># echo &quot;httpd:x:500:&quot; &gt; &#x2F;chroot&#x2F;apache&#x2F;etc&#x2F;group</span><br><span class="line"># cp &#x2F;lib&#x2F;libnss_dns.so.2 &#x2F;chroot&#x2F;apache&#x2F;lib </span><br><span class="line"># cp &#x2F;etc&#x2F;hosts &#x2F;chroot&#x2F;apache&#x2F;etc</span><br><span class="line"># cp &#x2F;etc&#x2F;resolv.conf &#x2F;chroot&#x2F;apache&#x2F;etc</span><br><span class="line"># mkdir &#x2F;chroot&#x2F;apache&#x2F;dev</span><br><span class="line"># mknod -m 666 &#x2F;chroot&#x2F;apache&#x2F;dev&#x2F;null c 1 3 </span><br><span class="line"># mknod -m 666 &#x2F;chroot&#x2F;apache&#x2F;dev&#x2F;zero c 1 5 </span><br><span class="line"># mknod -m 644 &#x2F;chroot&#x2F;apache&#x2F;dev&#x2F;random c 1 8</span><br><span class="line"># mkdir &#x2F;chroot&#x2F;apache&#x2F;tmp</span><br><span class="line"># chmod +t &#x2F;chroot&#x2F;apache&#x2F;tmp </span><br><span class="line"># chmod 777 &#x2F;chroot&#x2F;apache&#x2F;tmp</span><br><span class="line"># cp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;MET &#x2F;chroot&#x2F;apache&#x2F;etc&#x2F;localtime </span><br><span class="line"># mkdir -p &#x2F;chroot&#x2F;apache&#x2F;usr&#x2F;lib&#x2F;locale</span><br><span class="line"># set | grep LANG</span><br><span class="line">LANG&#x3D;en_US.UTF-8</span><br><span class="line">LANGVAR&#x3D;en_US.UTF-8</span><br><span class="line"># cp -dpR &#x2F;usr&#x2F;lib&#x2F;locale&#x2F;en_US.utf8 &#x2F;chroot&#x2F;apache&#x2F;usr&#x2F;lib&#x2F;locale</span><br></pre></td></tr></table></figure>
<p>接下来实操，to_page 67</p>
]]></content>
      <tags>
        <tag>openssl</tag>
        <tag>网络</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>operation-making</title>
    <url>/2021/03/19/operation-making/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>docker</title>
    <url>/2021/03/22/docker/</url>
    <content><![CDATA[<p>1.断言,泛型,虚函数回顾<br> 断言一般用于程序入参检查，可提高代码阅读性，泛型是抽象参数类型，减少重复代码。<br> 虚函数意在运行时决定调用哪一个具体函数实现，纯虚函数在基类中不定义实现，virtual void func()=0<br> 而虚函数在基类中有定义实现<br>2.namespaced的介绍</p>
<ul>
<li>UTS namespace<br> UTS namespace主要用来隔离nodename和domainname两个系统标识符，每个namespace允许有自己的hostname，新的UTS namespace中更改主机名不影响宿主机 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">&quot;os&#x2F;exec&quot;</span><br><span class="line">&quot;syscall&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line"> cmd:&#x3D;exec.Command(&quot;sh&quot;)</span><br><span class="line"> cmd.SysProcAttr&#x3D;&amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags:syscall.CLONE_NEWUTS,</span><br><span class="line">&#125;</span><br><span class="line">cmd.Stdin&#x3D;os.Stdin</span><br><span class="line">cmd.Stdout&#x3D;os.Stdout</span><br><span class="line">cmd.Stderr&#x3D;os.Stderr</span><br><span class="line">if err:&#x3D;cmd.Run();</span><br><span class="line">err!&#x3D;nil&#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>IPC Namespace<br>IPC Namespace用来隔离System V IPC和POSIX message queu(进程间通信用的，后面再出详细的专题来探究)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  package main</span><br><span class="line">import (</span><br><span class="line">&quot;os&#x2F;exec&quot;</span><br><span class="line">&quot;syscall&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line"> cmd:&#x3D;exec.Command(&quot;sh&quot;)</span><br><span class="line"> cmd.SysProcAttr&#x3D;&amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags:syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC,</span><br><span class="line">&#125;</span><br><span class="line">cmd.Stdin&#x3D;os.Stdin</span><br><span class="line">cmd.Stdout&#x3D;os.Stdout</span><br><span class="line">cmd.Stderr&#x3D;os.Stderr</span><br><span class="line">if err:&#x3D;cmd.Run();err!&#x3D;nil&#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>PID Namespace<br>PID Namespace 是用来隔离进程ID的，同养一个进程在不同的PID Namespace里可以拥有不同的PID<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">&quot;os&#x2F;exec&quot;</span><br><span class="line">&quot;syscall&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line"> cmd:&#x3D;exec.Command(&quot;sh&quot;)</span><br><span class="line"> cmd.SysProcAttr&#x3D;&amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags:syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID,</span><br><span class="line">&#125;</span><br><span class="line">cmd.Stdin&#x3D;os.Stdin</span><br><span class="line">cmd.Stdout&#x3D;os.Stdout</span><br><span class="line">cmd.Stderr&#x3D;os.Stderr</span><br><span class="line">if err:&#x3D;cmd.Run();err!&#x3D;nil&#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Mount Namespace<br>Mount Namespace用来隔离各个进程看到的挂载点视图，不同的Namespace进程中看到的文件系统层次不一样。是linux实现的第一个Namespace,系统调用参数是NEWNS,当时人们并没有意识到，以后还有很多累的Namespace加入linux大家庭<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">&quot;os&#x2F;exec&quot;</span><br><span class="line">&quot;syscall&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line"> cmd:&#x3D;exec.Command(&quot;sh&quot;)</span><br><span class="line"> cmd.SysProcAttr&#x3D;&amp;syscall.SysProcAttr&#123;</span><br><span class="line">        Cloneflags:syscall.CLONE_NEWUTS | syscall.CLONE_NEWIPC | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS,</span><br><span class="line">&#125;</span><br><span class="line">cmd.Stdin&#x3D;os.Stdin</span><br><span class="line">cmd.Stdout&#x3D;os.Stdout</span><br><span class="line">cmd.Stderr&#x3D;os.Stderr</span><br><span class="line">if err:&#x3D;cmd.Run();err!&#x3D;nil&#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
mount -t proc proc /proc  #挂载之后查看进程</li>
<li>User Namespace<br> 用来隔离用户组ID的，一个非root用户运行创建一个User Namespace可在里面映射成root用户</li>
<li>Network Namespace<br> 用来隔离网络设备,IP地址端口等资源的</li>
</ul>
<p>3.Cgroups的介绍<br>  Cgroup提供了一组进车过将子进程的资源限制控制和统计的能力，这些资源包括CPU,内存，存储，网络等。<br>  docker中限制内存使用 docker -m 128m xxxx<br> <figure class="highlight plain"><figcaption><span>main</span></figcaption><table><tr><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;os&#x2F;exec&quot;</span><br><span class="line">&quot;path&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;io&#x2F;ioutil&quot;</span><br><span class="line">&quot;syscall&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line">const cgroupMemoryHierarchyMount&#x3D;&quot;&#x2F;sys&#x2F;fs&#x2F;cgoup&#x2F;memory&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    if os.Args[0]&#x3D;&#x3D;&quot;&#x2F;proc&#x2F;self&#x2F;exe&quot; &#123;</span><br><span class="line">      fmt.Printf(&quot;current pid %d&quot;,syscall.Getpid())</span><br><span class="line">      fmt.Println()</span><br><span class="line">      cmd:&#x3D;exec.Command(&quot;sh&quot;,&quot;-c&quot;,&#96;stress --vm-bytes 50m --vm-keep -m 1&#96;)</span><br><span class="line">      cmd.SysProcAttr&#x3D;&amp;syscall.SysProcAttr&#123;</span><br><span class="line">        &#125;</span><br><span class="line">      cmd.Stdin&#x3D;os.Stdin</span><br><span class="line">      cmd.Stdout&#x3D;os.Stdout</span><br><span class="line">      cmd.Stderr&#x3D;os.Stderr</span><br><span class="line">      if err:&#x3D;cmd.Run();err!&#x3D;nil&#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">      os.Exit(1)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cmd:&#x3D;exec.Command(&quot;&#x2F;proc&#x2F;self&#x2F;exe&quot;)</span><br><span class="line">   cmd.SysProcAttr&#x3D;&amp;syscall.SysProcAttr&#123;</span><br><span class="line">      Cloneflags:syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWNS,</span><br><span class="line">   &#125;</span><br><span class="line">      cmd.Stdin&#x3D;os.Stdin</span><br><span class="line">      cmd.Stdout&#x3D;os.Stdout</span><br><span class="line">      cmd.Stderr&#x3D;os.Stderr</span><br><span class="line">      if err:&#x3D;cmd.Start();err!&#x3D;nil&#123;</span><br><span class="line">       fmt.Println(&quot;ERROR&quot;,err)</span><br><span class="line">       os.Exit(1)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">     fmt.Printf(&quot;%v&quot;,cmd.Process.Pid)</span><br><span class="line">     os.Mkdir(path.Join(cgroupMemoryHierarchyMount,&quot;testmemorylimit&quot;),0755)</span><br><span class="line">     ioutil.WriteFile(path.Join(cgroupMemoryHierarchyMount,&quot;testmemorylimit&quot;,&quot;tasks&quot;),[]byte(strconv.Itoa(cmd.Process.Pid)),0644)</span><br><span class="line">     ioutil.WriteFile(path.Join(cgroupMemoryHierarchyMount,&quot;testmemorylimit&quot;,&quot;memory.limit_in_bytes&quot;),[]byte(&quot;100m&quot;),0644)</span><br><span class="line">     &#125;</span><br><span class="line">cmd.Process.Wait()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br> 4.Union File System<br> 其用到的重要的资源管理技术叫“写时复制”，也叫”隐式共享“，AUFS完全重写早期的UnionFS 1.x，使用CoW技术，其主要目的是为了可靠性和性能，并且引入新的功能，比如可写的分支负载均衡，docker利用AUFS存储image和container<br> 启动一个container的时候，docker会为其创建一个read-only的init layer,用来存储与这个容器内环境相关的内容，Docker还会为其创建一个read-write的layer来执行所有的写操作。如果要删除文件file1，AUFS会在container的read-write层生成一个.wh.file1的文件来隐藏所有的read-only层的file1文件。<br>5.虚拟网络<br>  linux上虚拟网络</p>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>cgroup</tag>
        <tag>namespace</tag>
      </tags>
  </entry>
</search>
